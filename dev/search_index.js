var documenterSearchIndex = {"docs":
[{"location":"design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/#User-Interface","page":"Design","title":"User Interface","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"From a user's perspective, Bayesian inference requires a log joint density function ldg, which may or may not depend on some data. MCBayes further requires the dimension of the input to the log density gradient.  Consider the log joint density function of the Gaussian distribution's density function.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"function ldg(q; kwargs...)\n    return -q' * q / 2, -q\nend\ndims = 10\nq = randn(dims)\nldg(q)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The function ldg takes in a vector of length dims, and any number of keyword arguments, and returns a 2-tuple consisting of a scalar and a vector of the same length as the input.  The returned scalar is the evaluation of ldg at the input q.  The returned vector is the gradient of ldg evaluated at q.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"To obtain samples from the distribution corresponding to the log joint density function above, using the MCBayes implementation of Stan's dynamic Hamiltonian Monte Carlo algorithm, instantiate a Stan sampler object and pass it to the MCBayes function sample!(...).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"stan = Stan(dims)\ndraws, diagnostics, rngs = sample!(stan, ldg)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The output of sample!(...) is a 3-tuple.  The first element is a 3-dimensional array of draws (iterations x dimension x chains) from the distribution corresponding to the log joint density function ldg.  The second element is a tuple of diagnostics, which are meant to help the user evaluate the success (or lack thereof) of the sampling algorithm.  The third element is the random number generator seeds at the point that the sampling algorithm terminated.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The sampler object could be MEADS(dims), for an implentation of Tuning-Free Generalized Hamiltonian Monte Carlo, or MH(dims) for an implementation of the Metropolis algorithm which adaptatively tunes the metric for the proposal distribution and the stepsize.","category":"page"},{"location":"design/#Internal-API","page":"Design","title":"Internal API","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Almost the entire structure of all sampling algorithms of MCBayes fit into this one function.  For now, focus on only the arguments sampler and ldg, and the verbs/functions.  Try to ignore the adapters for just a moment.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"function run_sampler!(sampler::AbstractSampler, ldg;\n                      iterations = 1000,\n                      warmup = iterations,\n                      stepsize_adapter = StepsizeConstant(...),\n                      metric_adapter = MetricConstant(...),\n                      trajectorylength_adapter = TrajectorlengthConstant(...),\n                      damping_adapter = DampingConstant(...),\n                      noise_adapter = NoiseConstant(...),\n                      drift_adapter = DriftConstant(...),\n                      adaptation_schedule = WindowedAdaptationSchedule(warmup),\n                      ...\n                      )\n    M = iterations + warmup\n    draws = preallocate_draws(M, ...)\n    diagnostics = preallocate_diagnostics(...)\n\n    initialize_sampler!(sampler, ...)\n    initialize_draws!(draws, ldg, ...)\n    initialize_stepsize!(sampler, ldg, draws, ...)\n\n    for m in 1:M\n        transition!(sampler, m, ldg, draws, ...)\n        adapt!(sampler, adaptation_schedule, m, ldg, draws,\n               stepsize_adapter,\n               metric_adapter,\n               trajectorylength_adapter,\n               damping_adapter,\n               noise_adapter,\n               drift_adapter,\n               ...\n               )\n    end\n\n    return draws, diagnostics, rngs\nend","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"MCBayes makes heavy use of the multiple dispatch capabilities of Julia.  So each sampler gets its own transition!(...) function.  All samplers, so far, share the one adapt!(...) method, since the internals of adapt!(...) dispatch on appropriate adatpers.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"You may have noticed that the User Interface example calls sample!(...), not run_sampler!(...).  In fact, each sampler object, e.g. Stan, MEADS, MH, gets its own sample!(...) function which specifies the adaptation components appropriate to that sampler and then immediately calls run_sampler!(...).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"For instance, a default run of Stan uses Dual Averaging to adapt the stepsize during the warmup iterations.  So the function sample!(...) appropriate to Stan has signature something like","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"function sample!(sampler::Stan, ldg;\n                 iterations = 1000,\n                 warmup = iterations,\n                 stepsize_adapter = StepsizeDualAverage(sampler.stepsize),\n                 metric_adapter = MetricOnlineMoments(sampler.metric),\n                 adaptation_schedule = WindowedAdaptationSchedule(warmup),\n                 ...)\n    return run_sampler!(sampler,\n                        ldg;\n                        iterations,\n                        warmup,\n                        stepsize_adapter,\n                        metric_adapter,\n                        adaptation_schedule,\n                        kwargs...)\nend","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The function sample!(sampler::Stan, ...)  passes the adaptation components specific to Stan to run_sampler!(...), thus over-riding the adapters run_sampler!(...) otherwise defaults to.  Now is a good time to go look back at the default adapters of run_sampler!(...).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"All *Constant(...) adapters are effectively a no-op within adapt!(...).  The constant adapters are thus ignored when not appropriate for a particular sampler.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Consider the adapter TrajectorylengthConstant(...).  This has zero effect on the Stan sampler, since Stan's trajectory length is dynamically determined from a modern implementation of NUTS (see Michael Betancourt's A Conceptual Introduction to Hamiltonian Monte Carlo).  The dynamic trajectory length is computed within transition!(sampler::Stan, ...), namely the transition!(...) function appropriate to the Stan sampler.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The method adapt!(...) itself dispatches to particular adapt!(...) functions, dependent on the adaptation_schedule.  Right now, only Stan's windowed adaptation schedule is implemented.  The structure of adapt!(sampler, schedule::WindowedAdaptationSchedule, ...) looks something like","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"function adapt!(sampler, schedule::WindowedAdaptationSchedule,\n                m, ldg, draws,\n                stepsize_adapter,\n                metric_adapter,\n                trajectorylength_adapter,\n                damping_adapter,\n                noise_adapter,\n                drift_adapter,\n                ...)\n    # within warmup\n    if m <= sampler.warmup\n        # update and set stepsize\n        update!(stepsize_adapter, ...)\n        set!(sampler, stepsize_adapter, ...)\n\n        # update and set trajectory length\n        update!(trajectorylength_adapter; kwargs...)\n        set!(sampler, trajectorylength_adapter, ...)\n\n        # in appropriate windows, update (without setting) metric\n        if schedule.firstwindow <= m <= schedule.lastwindow\n            update!(metric_adapter, ...)\n        end\n\n        # at end of window\n        if m == schedule.closewindow\n            # re-initialize, set, and then reset stepsize\n            initialize_stepsize!(stepsize_adapter, ...)\n            set!(sampler, stepsize_adapter, ...)\n            reset!(stepsize_adapter, ...)\n\n            # set and then reset metric\n            set!(sampler, metric_adapter, ...)\n            reset!(metric_adapter)\n\n            calculate_nextwindow!(schedule)\n        end\n    else\n        set!(sampler, stepsize_adapter, ...)\n    end\nend","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"When a Stan sampler is passed into the adapt!(...) function above, the adapter within the variable trajectorylength_adapter has type TrajectorylengthConstant.  The method update!(...) dispatches to the function appropriate to this type and results in a no-op.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MCBayes","category":"page"},{"location":"#MCBayes.jl","page":"Home","title":"MCBayes.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MCBayes.jl is Julia package for Bayesian inference, which only depends on Julia standard library packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Stan\nsample!\nStepsizeDualAverage\nStepsizeConstant\nOnlineMoments\nupdate!\nPSPoint","category":"page"},{"location":"#MCBayes.Stan","page":"Home","title":"MCBayes.Stan","text":"Stan(dims, chains, T = Float64; kwargs...)\n\nInitialize Stan sampler object.  The number of dimensions dims and number of chains chains are the only required arguments.  The type T of the ...\n\nOptionally, via keyword arguments, can set the metric, stepsize, seed, maxtreedepth, and maxdeltaH.\n\n\n\n\n\n","category":"type"},{"location":"#MCBayes.StepsizeDualAverage","page":"Home","title":"MCBayes.StepsizeDualAverage","text":"StepsizeDualAverage(initial_stepsize::Vector)\n\nConstruct a stepsize adapter using the dual averaging method by Nesterov 2009, as used in Stan.  The length of initial_stepsize::Vector must be appropriate for the sampling algorithm for which this stepsize adapter will be used.\n\n\n\n\n\n","category":"type"},{"location":"#MCBayes.StepsizeConstant","page":"Home","title":"MCBayes.StepsizeConstant","text":"StepsizeConstant(initial_stepsize::Vector)\n\nConstruct a stepsize adapter for which the stepsize is fixed at it's initial value.\n\n\n\n\n\n","category":"type"},{"location":"#MCBayes.OnlineMoments","page":"Home","title":"MCBayes.OnlineMoments","text":"OnlineMoments(d, c, update = true)\n\nReturns an OnlineMoments struct with mean and variance Matrixes of size (d, c). When update!(om::OnlineMoments, x::Matrix) is called, update determines whether or not any updates will actually be applied.\n\n\n\n\n\n","category":"type"},{"location":"#MCBayes.update!","page":"Home","title":"MCBayes.update!","text":"Adam update.\n\n\n\n\n\nupdate!(om::OnlineMoments, x::Matrix; kwargs...)\n\nUpdate om's mean and variance Matrixes with the data contained in x. The rows of x and om.m (and thus om.v) must match.  The columns of x and om.m must either match or om.m must have only 1 column.  In the latter case, all columns of x will be used to update the same moments om.m and om.v.\n\n\n\n\n\nAdam update on log-scale.\n\n\n\n\n\n","category":"function"},{"location":"#MCBayes.PSPoint","page":"Home","title":"MCBayes.PSPoint","text":"Point in general phase space.\n\n\n\n\n\n","category":"type"}]
}
